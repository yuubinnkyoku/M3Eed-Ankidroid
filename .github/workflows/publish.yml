name: ðŸš€ Publish

on:
  workflow_dispatch:
    inputs:
      public:
        description: "any non-empty value triggers a public build - version not auto-incremented / changelog required"
        required: false
        type: string
      skip_play:
        description: "set to 'true' to skip Google Play upload even when making a public release"
        required: false
        type: string

# We want concurrency control to allow multiple runs, but serially
# Otherwise if you run two publishes that upload to google at same time
# (for instance on a release branch for beta, and main for alpha), google
# will error as it can only handle one edit in publish account at once
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  release_app:
    name: "Release App"
    timeout-minutes: 120
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - uses: actions/cache@v4
        name: Gradle Cache
        with:
          path: ~/.gradle/caches
          key: gradle-${{ hashFiles('**/*.gradle*') }}-v1

      - name: Configure JDK
        uses: actions/setup-java@v5
        with:
          distribution: "temurin"
          java-version: "21"

      - name: Install Release Utilities
        run: |
          sudo chown -R $USER /var/lib/gems/
          sudo chown -R $USER /usr/local/bin
          gem install asciidoctor
        shell: bash

      - name: GIT Setup
        run: |
          git config --global user.name 'Mike Hardy'
          git config --global user.email 'github@mikehardy.net'
          # Use HTTPS remote with token so we don't need SSH key for pushing tags
          git remote set-url origin https://x-access-token:${{ secrets.RELEASES_PUBLISH_TOKEN }}@github.com/${{ github.repository }}
        shell: bash

      # NOTE: We intentionally avoid installing SSH keys for this workflow as
      # we switch to HTTPS remote and cloning for GitHub operations. This prevents
      # libcrypto/ssh-add errors with mismatched OpenSSH formats on the runner.

      - name: Credential Prep
        if: "${{ github.event.inputs.public != '' }}" # publicãƒªãƒªãƒ¼ã‚¹ã®å ´åˆã®ã¿èªè¨¼æƒ…å ±ã‚’æº–å‚™
        run: |
          set -euo pipefail
          echo "KEYSTOREPATH=$HOME/src/android-keystore" >> $GITHUB_ENV
          echo "KEYALIAS=nrkeystorealias" >> $GITHUB_ENV
          echo "KEYSTOREPWD=DUMMY_KEYSTORE_PASSWORD" >> $GITHUB_ENV # ãƒ€ãƒŸãƒ¼å€¤
          echo "KEYPWD=DUMMY_KEYSTORE_KEY_PASSWORD" >> $GITHUB_ENV # ãƒ€ãƒŸãƒ¼å€¤
          mkdir -p ~/src
          cd ~/src

          # Functions to write secrets robustly:
          write_secret_as_gz() {
            local secret_value="$1"
            local out_gz="$2"
            local tmp
            tmp=$(mktemp)
            # Try to decode base64 into tmp
            if printf '%s' "$secret_value" | base64 -d > "$tmp" 2>/dev/null; then
              # If decoded output is a gzip archive, keep it as-is
              if gzip -t "$tmp" >/dev/null 2>&1; then
                mv "$tmp" "$out_gz"
                return 0
              else
                # Decoded content isn't gzip, compress it
                gzip -c "$tmp" > "$out_gz"
                rm -f "$tmp"
                return 0
              fi
            else
              # Not base64: write raw and compress
              printf '%s' "$secret_value" | sed 's/\r$//' | gzip > "$out_gz"
              rm -f "$tmp"
              return 0
            fi
          }

          write_secret_as_plain() {
            local secret_value="$1"
            local out_file="$2"
            # If it decodes as base64, decode it; otherwise write raw
            if printf '%s' "$secret_value" | base64 -d >/dev/null 2>&1; then
              printf '%s' "$secret_value" | base64 -d > "$out_file"
            else
              printf '%s' "$secret_value" | sed 's/\r$//' > "$out_file"
            fi
          }

          # Amazon / Google publish credentials are expected as .json.gz in the release script.
          if [ -n "${{ secrets.AMAZON_PUBLISH_CREDENTIALS }}" ]; then
            write_secret_as_gz "${{ secrets.AMAZON_PUBLISH_CREDENTIALS }}" ./AnkiDroid-Amazon-Publish-Security-Profile.json.gz
          else
            echo "Warning: AMAZON_PUBLISH_CREDENTIALS not set" >&2
          fi

          if [ -n "${{ secrets.GOOGLE_PUBLISH_CREDENTIALS }}" ]; then
            write_secret_as_gz "${{ secrets.GOOGLE_PUBLISH_CREDENTIALS }}" ./AnkiDroid-GCP-Publish-Credentials.json.gz
          else
            echo "Warning: GOOGLE_PUBLISH_CREDENTIALS not set" >&2
          fi

          # The Releases publish token is expected as a plain token file; try to decode base64 if encoded, otherwise write raw
          if [ -n "${{ secrets.RELEASES_PUBLISH_TOKEN }}" ]; then
            write_secret_as_plain "${{ secrets.RELEASES_PUBLISH_TOKEN }}" ./my-github-personal-access-token
          else
            echo "Warning: RELEASES_PUBLISH_TOKEN not set" >&2
          fi

          # Keystore may be passed in as base64-encoded data or raw; produce a gz archive for later gunzip step
          if [ -n "${{ secrets.KEYSTORE }}" ]; then
            write_secret_as_gz "${{ secrets.KEYSTORE }}" ./android-keystore.gz
          else
            echo "Warning: KEYSTORE secret not set" >&2
          fi

          # If we still have gz files, extract them so release.sh can find plain files
          if ls *.gz >/dev/null 2>&1; then
            gunzip -f *.gz || true
          fi
        shell: bash

      - name: Build and Release public release
        if: "${{ github.event.inputs.public != '' }}"
        env:
          SKIP_PLAY: ${{ github.event.inputs.skip_play }}
        run: |
          pushd ../
          # Use HTTPS clone to avoid SSH key requirement for cloning public docs repo
          git clone https://github.com/ankidroid/ankidroiddocs.git
          popd
          ./tools/release.sh public
        shell: bash

      - name: Build and Release test release
        if: "${{ github.event.inputs.public == '' }}"
        run: ./tools/release.sh
